SIMD C BACKEND REFERENCE
Vector LLVM
Rob Bocchino
October 21, 2005
========================

Overview
========

Vector LLVM extends the LLVM C backend to provide rudimentary support
for SIMD (fixed vector) code generation on PowerPC/AltiVec and
Intel/SSE2, via the AltiVec and SSE2 C APIs supported by gcc.  This
document describes the features and limitations of the AltiVec and
SSE2 code generators.  Note that the limitations are considerable!
This is a research prototype and a work in progress.

In the discusssion below, $(LLVMSRCDIR) means the "normal" (mainline)
LLVM top-level source directory, and $(VLLVMSRCDIR) means the
top-level source directory for Vector LLVM.

Backend Source Code
===================

Instruction selection for AltiVec and SSE is done via the LLVM-to-LLVM
transformation passes opt -altivec and opt -sse, defined in
$(VLLVMSRCDIR)/lib/Transforms/Vector/AltiVec.cpp and SSE.cpp.  These
passes perform pattern matching on Vector LLVM expressions written
with fixed vectors, and insert LLVM functions that can be written out
by the AltiVec and SSE C writers as C API functions, then fed through
gcc with the altivec or sse2 flag enabled.

The AltiVec and SSE writers subclass the CWriter class defined in
$(LLVMSRCDIR)/lib/Target/CBackend/Writer.cpp in mainline LLVM.  To
enable this, Vector LLVM pulls out the class definition for CWriter
into a separate file CWriter.h and makes some functions in CWriter
virtual, so they can be overridden by the SIMD backends.  Otherwise,
the functionality of the C backend itself is unchanged (i.e., any
scalar LLVM code will be converted to C by the C backend in the same
way as in mainline LLVM).  The SIMD backends themselves are defined in
TargetMachine and Writer files located in
$(VLLVMSRCDIR)/lib/Target/CBackend.  They define options
-march=altivec-c and -march=sse-c that can be invoked with llc to
write out C code with gcc vector functions.

Running the Backends
====================

As an example, code generation for AltiVec (on a PowerPC platform)
might look like this, where foo.vectorc.c is a Vector C program (q.v.)
that uses fixed vectors:

  llvm-gcc -I$(VLLVMSRCDIR)/include/VectorC foo.vectorc.c -o foo 
  opt -raisevectors -altivec < foo.bc | llc -march=altivec-c \
    > foo.altivec.cbe.c
  gcc -faltivec -O2 foo.cbe.c -o foo.altivec

Code generation for SSE on X86 might look like this:

  llvm-gcc -I$(VLLVMSRCDIR)/include/VectorC foo.vectorc.c -o foo 
  opt -raisevectors -sse < foo.bc | llc -march=sse-c > foo.sse.cbe.c
  gcc -msse2 -O2 foo.cbe.c -o foo.sse

Note that the -altivec and -sse passes must be explicitly invoked
before the C backend passes.  Setting up things
this way makes code generation easier to debug and develop;
unfortunately, it means that if the C backends are run on "raw" Vector
LLVM code (without the appropriate -altivec or -sse transformation
first), they will break.

What Works
==========

Don't expect to run arbitrary Vector LLVM code through the code
generation process described above and have it work.  Any legal Vector
LLVM code can be run through the -altivec or -sse passes to produce
more legal Vector LLVM (inapplicable constructs, such as variable
vectors, are just ignored).  However, unless the result is in a form
that the AltiVec or SSE backend can understand, the backend will choke
when it tries to write out the C file.  For example, if your Vector
LLVM program contains variable vectors, those vectors will be ignored
by the -altivec or -sse passes, but will cause the AltiVec or SSE C
writer to break.

Ideally, there would be a pass that scalarizes any vector patterns
that cannot be pattern matched and code generated by the -sse and
-altivec passes, but I haven't written that pass yet.  The point of
this experiment is to make high performance code, and I am not
interested in running code that I cannot vectorize anyway.  The
following sections describe what patterns of code can be successfully
recognized and translated by the AltiVec and SSE code generators.

Types
-----

The AltiVec and SSE2 writers understand the following vector types:

1. [vector of 4 int], [vector of 4 uint], [vector of 8 short], 
   [vector of 8 ushort], [vector of 16 sbyte], and 
   [vector of 16 ubyte].

2. Pointers to the types listed in (1).

In particular, this means you must block all loops manually on the
correct vector length.  I do not yet have a pass that will take
variable (long) vectors and block them to fixed vectors.

I have not tried to make arrays of vectors, put vectors in structs,
etc.  Such code may work, but I haven't tried it.  Any other vector
types (e.g., [vector of int] or [vector of 8 int]) will cause the
writers to break.  Any legal LLVM type with no vectors in it is, of
course, allowed, and will be handled by the normal C backend.

If your code is written with the types listed above only, and uses
patterns that the -altivec or -sse pass recognizes (as discussed
below), then it should go through the writer and produce correct code.
However, if your vector code uses patterns of operations that -altivec
or -sse passes cannot recognize, these passes can introduce types that
will break the writers.

Instructions
------------

fixed vimm

You should be able to use any fixed vimm instruction with AltiVec or
SSE, so long as it generates one of the types listed above.  Variable
vimm will not work.  For AltiVec, a fixed vimm instruction becomes
either a cast (in the case of a constant) or an altivec_splat
intrinsic (in the case of a nonconstant).  For SSE, a fixed vimm
becomes an _mm_splat macro, which expands to a _mm_set intrinsic.

extract

The AltiVec backend will convert the following pattern

   %lo = extract [vector of 16 sbyte] %val, uint 0, uint 1, uint 8
   %hi = extract [vecotr of 16 sbyte] %val, uint 8, uint 1, uint 8
   %unpklo = cast [vector of 16 sbyte] %lo to [vector of short]
   %unpkhi = cast [vector of 16 sbyte] %hi to [vector of short]

to the altivec_unpack_lo and altivec_unpack_hi intrinsics.  This only
works for the types stated above, and it only works on AltiVec.

combine

vselect

vsetcc

